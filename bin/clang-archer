#!/usr/bin/env python

import argparse
import errno
import json
import os
import re
import signal
import subprocess
import sys

VERSION = '0.1'

# Working Dirs
WORKING_DIR = os.getcwd()
BUILD_LIST = '/tmp/buildList.ach'
AR_FILE = '/tmp/ar.ach'
RANLIBD_FILE = '/tmp/ranlib.ach'
buildFile = None
ARCHER_DIR = '.archer'
INCLUDE_LIST = []

# Extensions
POLLY_BC_EXT = ".nomp.bc"
OMP_BC_EXT = ".bc"
OPT_EXT = ".opt"
BC_EXT = ".bc"
LL_EXT = ".ll"
BL_EXT = ".bl"
SOURCE_EXT = ['.c', '.cc', '.cpp', '.cxx']
OBJ_EXT = ['.o']
LIB_EXT = ['.a']
LOCAL_INCLUDE=[ "-I..", "-I../" ]

# Flags
ARCHER_DDA_FLAG = '-archer-dda'
LINKING=False
KEEP_LOGS=False

def signal_handler(signal, frame):
    print('You pressed Ctrl+C!')
    if not KEEP_LOGS:
        try:
            os.remove('/tmp/*.ach')
        except OSError, e:
            pass
    sys.exit(0)

class dotdict(dict):
    """dot.notation access to dictionary attributes"""
    def __getattr__(self, attr):
        return self.get(attr)
    __setattr__= dict.__setitem__
    __delattr__= dict.__delitem__

def mkdir_p(path):
    try:
        os.makedirs(path)
    except OSError as exc: # Python >2.5
        if exc.errno == errno.EEXIST and os.path.isdir(path):
            pass
        else: raise

def compileErrorCheck(p, cmd, output):
    if p.returncode:
        print >> sys.stderr, output
        sys.exit("Archer encountered an error when invoking [" + cmd[0] + ''.join(' ' + s for s in cmd[1:]) + "]. Exiting...")
        
def executeCommand(cmd, args):
    if args is not None and args.debug:
        print('DEBUG-INFO: Command[' + cmd[0] + ''.join(' ' + s for s in cmd[1:]) + ']')
    p = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
    output = p.communicate()[0]
    if output is not '':
        print output
    compileErrorCheck(p, cmd, output)

def argumentsParser():
    parser = argparse.ArgumentParser(add_help=False)
    parser.add_argument('-v', '--version', action='version', version='Archer ' + VERSION + '\nCopyright (C) 2015')
    parser.add_argument('-d', '--debug', action='store_true', help='Print the compiling commands')
    parser.add_argument('--log', action='store_true', help='Keep intermediate logs')
    parser.add_argument('-CC', nargs='?', default='clang', help='Change the program used to compile and link the programs')
    parser.add_argument('-OPT', nargs='?', default='opt', help='Change the program used to optmize the programs')
    parser.add_argument('-LINK', nargs='?', default='llvm-link', help='Change the program used to link the byte code files')
    parser.add_argument('-DIS', nargs='?', default='llvm-dis', help='Change the program used to disassemble the byte code files')
    parser.add_argument('-LIB', nargs='?', default='libArcher.so', help='Set the path where to find Archer libraries')
    parser.add_argument('-PLUGIN_LIB', nargs='?', default='ArcherPlugin.so', help='Set the path where to find Archer Plugin libraries')
    # parser.add_argument('-OPENMP_INCLUDE', nargs='?', default='', help='Set the path where to find OpenMP headers')
    # parser.add_argument('-MPI_INCLUDE', nargs='?', default='', help='Set the path where to find MPI headers')
    # parser.add_argument('-MPI_LIB', nargs='?', default='', help='Set the path where to find MPI libraries')
    # parser.add_argument('-g', action='store_true')       
    parser.add_argument('-g', action='store_true', help='If the debugging flag is not present in the compilation command it will be added by default')
    parser.add_argument('-O0', '-O1', '-O2', '-O3', '-Os', '-Oz', action='store_true', help='The optimization flags will be forse to \'-O0\' optimization level for analysis purposes')
    parser.add_argument('-fopenmp', action='store_true', help='OpenMP flag')
    parser.add_argument('-c', nargs="?", default=None, help='Only run preprocess, compile, and assemble steps')
    parser.add_argument('-o', help='Output filename')

    return parser

def archerBuild(args):
    
    mkdir_p('.archer')

    # Create ByteCode
    # No OpenMP Support
    clangCommand = [ args.CC ]
    clangCommand += [ "-emit-llvm", "-O0", "-g", "-c", args.src, "-o", ARCHER_DIR + "/" + args.o + POLLY_BC_EXT ]
    clangCommand.extend(args.unknown)
 
    executeCommand(clangCommand, args)
    # No OpenMP Support

    # OpenMP Support
    clangCommand = [ args.CC ]
    clangCommand += [ "-emit-llvm", "-O0", "-g", "-fopenmp", "-c", args.src, "-o", ARCHER_DIR + "/" + args.o + OMP_BC_EXT ]
    clangCommand.extend(args.unknown)
    executeCommand(clangCommand, args)
    # OpenMP Support
    # Create ByteCode

    # Changing dir to WORKING_DIR
    #os.chdir(ARCHER_DIR)
   
    # Polly Pass
    optCommand = [ args.OPT ]
    optCommand += [ '-mem2reg', ARCHER_DIR + "/" + args.o + POLLY_BC_EXT, "-o", ARCHER_DIR + "/" + args.o + POLLY_BC_EXT + OPT_EXT ]
    executeCommand(optCommand, args)

    optCommand = [ args.OPT ]
    optCommand += [ '-S', '-polly-canonicalize', ARCHER_DIR + "/" + args.o + POLLY_BC_EXT + OPT_EXT, "-o", ARCHER_DIR + "/" + args.o + LL_EXT ]
    executeCommand(optCommand, args)
    
    optCommand = [ args.OPT ]
    optCommand += [ '-load', args.LIB, ARCHER_DDA_FLAG, ARCHER_DIR + "/" + args.o + LL_EXT, "-o", ARCHER_DIR + "/" + args.o + "-optmized" + LL_EXT ]
    executeCommand(optCommand, args)
    # Polly Pass

    # Clang Plugin to find OpenMP constructs information
    clangCommand = [ args.CC ]
    clangCommand += [ "-O0", "-g", "-fopenmp", "-c", args.src ]
    clangCommand.extend(args.unknown)
    # lst = filter(lambda item: any(x in item for x in LOCAL_INCLUDE), args.unknown)
    # if lst:
    #     clangCommand += [ "-I../.."]
    # clangCommand.extend(INCLUDE_LIST)
    clangCommand += [ "-fsyntax-only", "-Xclang", "-load", "-Xclang", args.PLUGIN_LIB, "-Xclang", "-plugin", "-Xclang", "archer" ]
    executeCommand(clangCommand, args)
    # Clang Plugin to find OpenMP constructs information

def archerLink(args):
    print "Ready for linking..."

    # Creating and changing to WORKING_DIR
    mkdir_p('.archer')
    # os.chdir(ARCHER_DIR)

    builds = []
    bcLst = []
    # Read files to compile
    with open(BUILD_LIST, "r") as f:
        for line in f:
            lst = []
            spl = line.split(",",2)
            bc = spl[1].rsplit("/", 1)
            bcLst.append(bc[0] + "/" + ARCHER_DIR + "/" + bc[1] + BC_EXT)
            lst.append(spl[0])
            lst.append(spl[1])
            lst.append(dotdict(json.loads(spl[2])))
            builds.append(lst)
    # Read files to compile

    # Link byte code and run InstructionContext Pass
    linkCommand = [ args.LINK ]
    linkCommand += [ "-o", ARCHER_DIR + "/" + args.o + BC_EXT ]
    linkCommand.extend(bcLst)
    executeCommand(linkCommand, args)

    linkCommand = [ args.LINK ]
    linkCommand += [ "-f", ARCHER_DIR + "/" + args.o + BC_EXT, "-o", ARCHER_DIR + "/" + args.o + LL_EXT ]
    executeCommand(linkCommand, args)

    optCommand = [ args.OPT ]
    optCommand += [ "-load", args.LIB, "-archer-instcontext", ARCHER_DIR + "/" + args.o + LL_EXT, "-o", ARCHER_DIR + "/" + args.o + BC_EXT ]
    executeCommand(optCommand, args)
    # Link byte code and run InstructionContext Pass            

    # Create blacklists and compile with fsanitize
    for item in builds:
        blCommand = [ "archer-bl" ]
        blCommand += [ item[0], "0" ]
        executeCommand(blCommand, args)

        arg = item[2]
        clangCommand = [ arg.CC ]
        clangCommand += [ "-g", "-O0" ]
        if(arg.fopenmp):
            clangCommand += [ "-fopenmp" ]
        lst = item[0].rsplit("/", 1)
        blacklist = lst[0] + "/.archer/blacklists/" + lst[1] + BL_EXT
        clangCommand += [ "-fsanitize=thread", "-fsanitize-blacklist=" + blacklist, "-o", item[1], "-c", item[0]]
        clangCommand.extend(arg.unknown)
        executeCommand(clangCommand, args)
    # Create blacklists and compile with fsanitize

    # Check if an ar command has been executed
    # if so execute them else link the object
    # files all together
    if os.path.isfile(AR_FILE):
        try:
            with open(AR_FILE, 'r') as file:
                # Create libraries
                pass    
        except IOError as e:
            print "clang-argcher: No such file or directory or no read permissions"
    else:
        try:
            with open(AR_FILE, 'r') as file:
                # Link objects file together
                pass    
        except IOError as e:
            print "clang-argcher: No such file or directory or no read permissions"
        pass

    # if not KEEP_LOGS:
    #     os.remove('/tmp/*.ach')

if __name__ == '__main__':

    signal.signal(signal.SIGINT, signal_handler)

    buildFile = open(BUILD_LIST, "a")

    # Create include dir list
    os.chdir("..")
    for dir in os.walk(os.getcwd()):
        for file in os.listdir(dir[0]):
            if(str(file).endswith(".h")):
                INCLUDE_LIST.append("-I" + dir[0])
                break
    os.chdir(WORKING_DIR)
    # Create include dir list

    # parse command line arguments
    parser = argparse.ArgumentParser(formatter_class=argparse.RawDescriptionHelpFormatter, description='Compile your program with Archer support, a data race detector for OpenMP programs.', parents=[argumentsParser()])
    args, unknown = parser.parse_known_args()

    KEEP_LOGS = args.log

    # find source file .c, .cc, .cpp, .cxx in unknown arguments
    if args.c is None:
        for arg in unknown:
            if any(arg.endswith(ext) for ext in SOURCE_EXT):
                args.__dict__['src'] = arg
                unknown.remove(arg)
                args.__dict__['unknown'] = unknown
                break
        if 'src' not in args.__dict__:
            for arg in unknown:
                if any(arg.endswith(ext) for ext in OBJ_EXT):
                    args.__dict__['src'] = None
                    args.__dict__['obj'] = arg
                    unknown.remove(arg)
                    args.__dict__['unknown'] = unknown
                    LINKING=True
                    break
            else:
                sys.exit("Archer encountered an error when parsing parameters. Exiting...")
    else:
        args.__dict__['src'] = args.c
        args.__dict__['unknown'] = unknown

    # archerLink(args)
    # sys.exit()    

    # Keep list of compiled file
    if args.src is not None:
        buildFile.write(os.path.abspath(args.src) + "," + os.path.abspath(args.o) + "," + json.dumps(args.__dict__) + '\n')
    buildFile.close()

    # args.OPENMP_INCLUDE = "-I" + args.OPENMP_INCLUDE if (args.OPENMP_INCLUDE is not '') else ''
    # args.MPI_INCLUDE = "-I" + args.MPI_INCLUDE if (args.MPI_INCLUDE is not '') else ''

    if not LINKING:
        archerBuild(args)
    else:
        archerLink(args)
